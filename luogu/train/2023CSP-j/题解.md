# csp-j题解
## 第一题：小苹果
原题[洛谷P9748](https://www.luogu.com.cn/problem/P9748)  
### 题目描述
小 Y 的桌子上放着 $n$ 个苹果从左到右排成一列，编号为从 $1$ 到 $n$。  
小苞是小 Y 的好朋友，每天她都会从中拿走一些苹果。  
每天在拿的时候，小苞都是从左侧第 $1$ 个苹果开始、每隔 $2$ 个苹果拿走 $1$ 个苹果。随后小苞会将剩下的苹果按原先的顺序重新排成一列。  
小苞想知道，多少天能拿完所有的苹果，而编号为 $n$ 的苹果是在第几天被拿走的？
### 输入格式
输入的第一行包含一个正整数 $n$，表示苹果的总数。
### 输出格式
输出一行包含两个正整数，两个整数之间由一个空格隔开，分别表示小苞拿走所有苹果所需的天数以及拿走编号为 $n$ 的苹果是在第几天。
### 样例 #1
#### 样例输入 #1
```
8
```
#### 样例输出 #1
```
5 5
```
### 提示
**【样例 $1$ 解释】**
小苞的桌上一共放了 $8$ 个苹果。  
小苞第一天拿走了编号为 $1$、$4$、$7$ 的苹果。  
小苞第二天拿走了编号为 $2$、$6$ 的苹果。  
小苞第三天拿走了编号为 $3$ 的苹果。  
小苞第四天拿走了编号为 $5$ 的苹果。  
小苞第五天拿走了编号为 $8$ 的苹果。    
**【样例 $2$】**
见选手目录下的 apple/apple2.in 与 apple/apple2.ans。  
**【数据范围】**
对于所有测试数据有：$1\leq n\leq 10^9$。
| 测试点 | $n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 2$ | $10$ | 无 |
| $3\sim 5$ | $10^3$ | 无 |
| $6\sim 7$ | $10^6$ | 有 |
| $8\sim 9$ | $10^6$ | 无 |
| $10$ | $10^9$ | 无 |
特殊性质：小苞第一天就取走编号为 $n$ 的苹果。
### 思路  
这题还是很简单的，稍微模拟一下就看的出来规律了 
先对题意进行模拟
||1|2|3|4|5|6|7|8|9|
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
|第一天|1|||1|||1|||
|第二天||1||||1||||
|第三天|||1||||||1|
|第四天|||||1|||||
|第五天||||||||1||
---
然后开始打暴力模拟题意  ~~就会TLE~~

~~~
#include <iostream>
using namespace std;
const int N=1e6+5;
int n,a[N],day,day2;
int main(){
    freopen("apple.in","r",stdin);
    freopen("apple.out","w",stdout);
    cin>>n;
    while(1){
        int out=0;
        for(int i=1;i<=n;i++)
        {
            if(!a[i]){
                out++;
                if(out%3==1) a[i]=1;
            }
        }
        day++;
        if(a[n]==1) 
        {
            cout<<day<<endl;
            break;
        }
    }
    while(n){
        n=n-(n-1)/3-1;
        day2++;
    }
    cout<<day2;
    return 0;
}
~~~
结果如下  
![](https://cdn.luogu.com.cn/upload/image_hosting/9cdjxe4v.png)
(好像是我的问题？)  
~~这暴力比我的正解难打多了~~  
### 分析一下  
求几天取完很简单，每天会取走(n-1)/3+1个苹果，将原来的长度减去每天取走的长度，直到长度为0，用了几天就是几天。  
第 $n$ 个苹果第几天被取走可以这样想(个人思路)  
题目里有这样一句话
>每天在拿的时候，小苞都是从左侧第 $1$ 个苹果开始、每隔 $2$ 个苹果拿走 $1$ 个苹果。随后小苞会将剩下的苹果按原先的顺序重新排成一列。  

于是自然地想到，每次取完苹果后剩下的苹果会形成一个新的更短的序列  
比如：一开始有 $ 9 $ 个苹果，需要取第 $ 9 $ 个  
在第一天取完后，就变为：有 $6$ 个苹果，需要取第 $ 6 $ 个  
在第二天取完后，就变为：有 $4$ 个苹果，需要取第 $4$ 个  
………………  
依次递推，直到恰好取到最后一个苹果

于是想：当最后一个苹果位于什么位置时，恰好能被取得  
根据题意，易得：当序列长度为k * 3 + 1时，即最后一个苹果位于k * 3 + 1时刚好能被取到(k为整数)  
那么代码如下
~~~
#include <iostream>
#include <cstdio>
using namespace std;
int main() {
    freopen("apple.in","r",stdin);
    freopen("apple.out","w",stdout);
	int n,tn=1,day=0;
	scanf("%d", &n);
	int m = n;
	while ((m - 1) % 3 != 0) {
		tn++;
		m = m - (m - 1) / 3 - 1;
	}
	while (n) {
		day++;
		n = n - (n - 1) / 3 - 1;
	}
	printf("%d %d", day, tn);
	return 0;
}
~~~
结果如下：  
![](https://images.cnblogs.com/cnblogs_com/blogs/811181/galleries/2377257/o_240205005759_QQ%E6%88%AA%E5%9B%BE20240205081656.jpg)
时间复杂度约为O( $2*log_3n$ )稳过  
最坏约为$18.86313*2$（精确计算）  
但两个while循环是可以只写成一个的  
如下
~~~
//虽然没什么用，但是As the saying goes,"Vegetable,就多practice"
#include <iostream>
#include <cstdio>
int n,tn=1,day=0,k;
using namespace std;
void solve(){
    scanf("%d",&n);
    while (n){
        if ((n-1)%3!=0&&k==0)tn++;
        else k=1;
        day++;
        n=n-(n-1)/3-1;
    }
    printf("%d %d",day,tn);
}
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    freopen("apple.in", "r", stdin);
    freopen("apple.out", "w", stdout);
    solve();
    return 0;
}
~~~
结果如下
![](https://images.cnblogs.com/cnblogs_com/blogs/811181/galleries/2377257/o_240209140318_QQ%E6%88%AA%E5%9B%BE20240209220233.jpg)  
快不了一点
_______________________
## 第二题:公路  
原题[洛谷P9749](https://www.luogu.com.cn/problem/P9749)  
### 题目描述
小苞准备开着车沿着公路自驾。  
公路上一共有 $n$ 个站点，编号为从 $1$ 到 $n$。其中站点 $i$ 与站点 $i + 1$ 的距离为 $v_i$ 公里。  
公路上每个站点都可以加油，编号为 $i$ 的站点一升油的价格为 $a_i$ 元，且每个站点只出售整数升的油。  
小苞想从站点 $1$ 开车到站点 $n$，一开始小苞在站点 $1$ 且车的油箱是空的。已知车的油箱足够大，可以装下任意多的油，且每升油可以让车前进 $d$ 公里。问小苞从站点 $1$ 开到站点 $n$，至少要花多少钱加油？  
### 输入格式
输入的第一行包含两个正整数 $n$ 和 $d$，分别表示公路上站点的数量和车每升油可以前进的距离。  
输入的第二行包含 $n - 1$ 个正整数 $v_1, v_2\dots v_{n-1}$，分别表示站点间的距离。  
输入的第三行包含 $n$ 个正整数 $a_1, a_2 \dots a_n$，分别表示在不同站点加油的价格。  
### 输出格式
输出一行，仅包含一个正整数，表示从站点 $1$ 开到站点 $n$，小苞至少要花多少钱加油。  
### 样例 #1
#### 样例输入 #1
```
5 4
10 10 10 10
9 8 9 6 5
```
#### 样例输出 #1
```
79
```
### 提示
**【样例 1 解释】**  
最优方案下：小苞在站点 $1$ 买了 $3$ 升油，在站点 $2$ 购买了 $5$ 升油，在站点 $4$ 购买了 $2$ 升油。  
**【样例 2】**  
见选手目录下的 road/road2.in 与 road/road2.ans。  
**【数据范围】**  
对于所有测试数据保证：$1 \leq n \leq 10^5$，$1 \leq d \leq 10^5$，$1 \leq v_i \leq 10^5$，$1 \leq a_i \leq 10^5$。  
| 测试点 | $n \leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 5$ | $8$ | 无 |
| $6\sim 10$ | $10^3$ | 无 |
| $11\sim 13$ | $10^5$ | A |
| $14\sim 16$ | $10^5$ | B |
| $17\sim 20$ | $10^5$ | 无 |

- 特殊性质 A：站点 $1$ 的油价最低。
- 特殊性质 B：对于所有 $1 \leq i < n$，$v_i$ 为 $d$ 的倍数。
### 思路
一眼贪心 
>假设现在公路是有n个加油站，现在小苞位于$a$加油站，后面有$m$个加油站，每个加油站加油的价格都不相同  
>1.如果后面$m$个加油站的加油的价格都比$a$加油站贵，那么直接加到恰好能走完全程的油,因为后面的加油站无论在那个停下加油都会更贵  
>2.如果后面的$m$个加油站中，第一个比$a$加油站加油费便宜的是$b$加油站，则在$a$加油站加足量的油恰好能到b加油站，到b加油站加油  
>每到一个加油站，执行上述两个操作直到走完全程    

上述这些大概就是程序要做的
没必要到一个点就把整条路都扫一遍  
两种做法  
1. 1.记录加油所需的钱，与到达的加油站的价格进行比较，如果价格更低廉的话，就记录当前 加油站的价格，否则依然记录之前加油所需的钱，然后对油费进行计算  
    2.以1为起点的最长下降序列，就是提前找好在哪些地方加油(写不来)
2. 完全背包  
---
#### 1.1
需要注意的一点就是
>**每个站点只出售整数升的油**  

这样就会导致一个问题:到达下一个加油站可能油桶里的油会有剩余(比如样例1中1加油站到2加油站)，再用两站之间的距离除油的价钱算得的油量会多出一些  
所以为了解决这个问题，我们需要用一个变量 $gv$ 来记录从第 $1$ 个车站到第 $i$ 个车站之间的距离，让后用 $gv$ 减去已经加的油 $tv$ 与每升油可以前进的距离 $d$ 相乘的到的积，就可以的到实际上应加油支持走的路程  
还有：**不开 $long long$ 见祖宗**  
代码如下：  
~~~
#include <iostream>
#include <cmath>
using namespace std;
const int N=1e5+5;
long long n,d,v[N],a[N],w,x=N,tv,allv,gv;
void solve(){
    cin>>n>>d;
    for(int i=1;i<=n-1;i++) cin>>v[i],allv+=v[i];
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1,v1;i<n;i++)
    {
        gv+=v[i];
        x=min(x,a[i]);
        v1=ceil((gv-tv*d)*1.0/d);
        tv+=v1;
        w+=x*v1;
    }
    cout<<w;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    freopen("road.in","r",stdin);
    freopen("road.out","w",stdout);
    solve();
    return 0;
}
~~~
结果如下  
![](https://images.cnblogs.com/cnblogs_com/blogs/811181/galleries/2377257/o_240209140907_QQ%E6%88%AA%E5%9B%BE20240209220801.jpg)  
时间复杂度O(3*n) 稳过
___
#### 1.2   
没有写，以后有机会补上？
___
#### 2.背包  
我是想不到用背包做，这里是题解区dalao的东西  
~~想到了也实现不来~~  
原作者[xvl_](https://www.luogu.com.cn/user/760266)  
在 dp 之前，我们需要明确以下几个东西：  
**状态的表示，状态转移方程，边界条件跟答案的表示。**
状态的表示 $ dp_i $ 表示到达第 $i$ 个站点所需要的最少钱数， $w_i$ 表示在使用最少钱数到达第 $i$ 个站点时多余的路程。  
状态转移方程  
    $dp_i=dp_{i-1}+(v_{i-1}-w_{i-1})/d*premin(i-1)$  
    $w_i=(v_{i-1}-w_{i-1})/d-v_{i-1}+w_{i-1}$  
其中 $premin(i-1)$ 表示前 $i$ 个站点中最小的油价。  
边界条件  
$dp_i=0$  
$w_i=0$  
答案的表示  
$dp_n$
~~~
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
ll n, d, ans;
ll v[100005], a[100005], dp[100005], pm[100005], w[100005];
int main() {
	freopen("road.in", "r", stdin);
	freopen("road.out", "w", stdout);
	ios :: sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	cin >> n >> d;
	pm[0] = 1e18;
	for (int i = 1; i < n; i++) cin >> v[i];
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		pm[i] = min(pm[i - 1], a[i]);
	}
	for (int i = 2; i <= n; i++) {
		dp[i] = dp[i - 1] + ceil(1.0 * (v[i - 1] - w[i - 1]) / d) * pm[i - 1];
		w[i] = ceil(1.0 * (v[i - 1] - w[i - 1]) / d) * d - (v[i - 1] - w[i - 1]);
	}
	cout << dp[n];
	return 0;
}
~~~
结果如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/s07bdsng.png)
因为输入输出的原因看起来快了一点
___
## 第三题：一元二次方程
原题[洛谷P9750](https://www.luogu.com.cn/problem/P9750)
### 题目背景
众所周知，对一元二次方程 $ax ^ 2 + bx + c = 0, (a \neq 0)$，可以用以下方式求实数解：  
- 计算 $\Delta = b ^ 2 - 4ac$，则:
	1. 若 $\Delta < 0$，则该一元二次方程无实数解。
  	2. 否则 $\Delta \geq 0$，此时该一元二次方程有两个实数解 $x _ {1, 2} = \frac{-b \pm \sqrt \Delta}{2a}$。  
例如：  
- $x ^ 2 + x + 1 = 0$ 无实数解，因为 $\Delta = 1 ^ 2 - 4 \times 1 \times 1 = -3 < 0$。
- $x ^ 2 - 2x + 1 = 0$ 有两相等实数解 $x _ {1, 2} = 1$。
- $x ^ 2 - 3x + 2 = 0$ 有两互异实数解 $x _ 1 = 1, x _ 2 = 2$。  
在题面描述中 $a$ 和 $b$ 的最大公因数使用 $\gcd(a, b)$ 表示。例如 $12$ 和 $18$ 的最大公因数是 $6$，即 $\gcd(12, 18) = 6$。
### 题目描述
现在给定一个一元二次方程的系数 $a, b, c$，其中 $a, b, c$ **均为整数且 $a \neq 0$**。你需要判断一元二次方程 $a x ^ 2 + bx + c = 0$ 是否有实数解，并按要求的格式输出。  
**在本题中输出有理数 $v$ 时须遵循以下规则：**  
- 由有理数的定义，存在唯一的两个整数 $p$ 和 $q$，满足 $q > 0$，$\gcd(p, q) = 1$ 且 $v = \frac pq$。
- 若 $q = 1$，**则输出 `{p}`，否则输出 `{p}/{q}`**，其中 `{n}` 代表整数 $n$ 的值；
- 例如：

	- 当 $v = -0.5$ 时，$p$ 和 $q$ 的值分别为 $-1$ 和 $2$，则应输出 `-1/2`；
   - 当 $v = 0$ 时，$p$ 和 $q$ 的值分别为 $0$ 和 $1$，则应输出 `0`。  
**对于方程的求解，分两种情况讨论：**    
1. 若 $\Delta = b ^ 2 - 4ac < 0$，则表明方程无实数解，此时你应当输出 `NO`；
2. 否则 $\Delta \geq 0$，此时方程有两解（可能相等），记其中较大者为 $x$，则：
	1. 若 $x$ 为有理数，则按有理数的格式输出 $x$。
   2. 否则根据上文公式，$x$ 可以被**唯一**表示为 $x = q _ 1 + q _ 2 \sqrt r$ 的形式，其中：  
   		- $q _ 1, q _ 2$ 为有理数，且 $q _ 2 > 0$；
      - $r$ 为正整数且 $r > 1$，且不存在正整数 $d > 1$ 使 $d ^ 2 \mid r$（即 $r$ 不应是 $d ^ 2$ 的倍数）；

   此时：  
   1. 若 $q _ 1 \neq 0$，则按有理数的格式输出 $q _ 1$，并再输出一个加号 `+`；
   2. 否则跳过这一步输出； 

   随后：
   
   1. 若 $q _ 2 = 1$，则输出 `sqrt({r})`；
   2. 否则若 $q _ 2$ 为整数，则输出 `{q2}*sqrt({r})`；
   3. 否则若 $q _ 3 = \frac 1{q _ 2}$ 为整数，则输出 `sqrt({r})/{q3}`；
   4. 否则可以证明存在唯一整数 $c, d$ 满足 $c, d > 1, \gcd(c, d) = 1$ 且 $q _ 2 = \frac cd$，此时输出 `{c}*sqrt({r})/{d}`；  

   上述表示中 `{n}` 代表整数 `{n}` 的值，详见样例。  
   如果方程有实数解，则按要求的格式输出两个实数解中的较大者。否则若方程没有实数解，则输出 `NO`。
### 输入格式
输入的第一行包含两个正整数 $T$ , $M$ ，分别表示方程数和系数的绝对值上限。  
接下来 $T$ 行，每行包含三个整数 $a, b, c$。  
### 输出格式
输出 $T$ 行，每行包含一个字符串，表示对应询问的答案，格式如题面所述。  
**每行输出的字符串中间不应包含任何空格**。  
### 样例 #1
#### 样例输入 #1
```
9 1000
1 -1 0
-1 -1 -1
1 -2 1
1 5 4
4 4 1
1 0 -432
1 -3 1
2 -4 1
1 7 1
```
#### 样例输出 #1
```
1
NO
1
-1
-1/2
12*sqrt(3)
3/2+sqrt(5)/2
1+sqrt(2)/2
-7/2+3*sqrt(5)/2
```
### 提示
**【样例 #2】**  
见附件中的 `uqe/uqe2.in` 与 `uqe/uqe2.ans`。  
**【数据范围】**  
对于所有数据有：$1 \leq T \leq 5000$，$1 \leq M \leq 10 ^ 3$，$|a|,|b|,|c| \leq M$，$a \neq 0$。  
| 测试点编号 | $M \leq$ | 特殊性质 A | 特殊性质 B | 特殊性质 C |
| :-: | :-: | :-: | :-:| :-:|
| $1$ | $1$ | 是 | 是 | 是 |
| $2$ | $20$ | 否 | 否 | 否 |
| $3$ | $10 ^ 3$ | 是 | 否 | 是 |
| $4$ | $10 ^ 3$  | 是 | 否 | 否 |
| $5$ | $10 ^ 3$  | 否 | 是 | 是 |
| $6$ | $10 ^ 3$  | 否 | 是 | 否 |
| $7, 8$ | $10 ^ 3$  | 否 | 否 | 是 |
| $9, 10$ | $10 ^ 3$  | 否 | 否 | 否 |

其中：  
- 特殊性质 A：保证 $b = 0$；
- 特殊性质 B：保证 $c = 0$；
- 特殊性质 C：如果方程有解，那么方程的两个解都是整数。
___
从未想过有一天会栽在一元二次方程上(数学老师看到我这题0分肯定笑死我)
### 分析
~~没什么好分析的大模拟就对了~~  
额，模拟题基本上没有算法什么之类的  
所以只能分条解释了(以下解释没有先后关系)  
1. 在数学里，一元二次方程的解均有两个，格式为 $x_1=\frac{-b+\sqrt\delta}{2 \times a},x_2=\frac{-b+\sqrt\delta}{2 \times a}$(即便是$\delta=0$，也被认为是$x_1=x_2=\frac{-b}{2 \times a}$),题目只要求我们输出较大的根，此时这个较大的根有两种情况：因为$\sqrt\delta\geq0$,所以$-b+\sqrt\delta\geq-b-\sqrt\delta$，则：  
    1.当$a>0$时，最大值为$x=\frac{-b+\sqrt\delta}{2 \times a}$  
	2.当$a<0$时，最大值为$x=\frac{-b-\sqrt\delta}{2 \times a}$  
然后就是分类讨论，反正挺累的  
为了稍微少模拟点，我选择将$a$都变为正数
 ~~~
 if(a<0) a=-a,b=-b,c=-c;
 ~~~
2. 开根，反正不能用sqrt()函数，手写了一个用来开根的函数
~~~
int ti(int n){
    for(int i=2;i*i<=n;i++){
        if(n%(i*i)==0) return i*ti(n/(i*i));
    }
    return 1;
}
~~~
3. 约分 简而言之就是找到分子与分母之间的最大公约数然后各自除去就行  
最大公约数用辗转相除法求  
~~~
int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}
~~~
4. 输出，本题最烦人的模拟
有以下几点需要特殊处理的地方  
    1. 分母为1则不输出分母  
	2. 根号前的乘数为1则不输出  
	3.  $-b/2a=0$则不输出  
	4. $\frac{\sqrt\delta}{2 \times a}=0$则不输出  

总结完了，可惜看完分析并不能帮助谁写完代码，因为以上都是一些大家都能发现的，实现代码，关键还是要自己打一遍    
那么代码如下：  
~~~
#include <iostream>
#include <algorithm>
using namespace std;
int t,m;
int ti(int n){
    for(int i=2;i*i<=n;i++){
        if(n%(i*i)==0) return i*ti(n/(i*i));
    }
    return 1;
}
int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}
void solve(){
    int a,b,c,delta;
    cin>>a>>b>>c;
    if(a<0) a=-a,b=-b,c=-c;
    delta=b*b-4*a*c;
    if(delta<0) {cout<<"NO"<<endl;return;}
    int k=ti(delta);
    if(k*k==delta){
        int f=abs(gcd(2*a,-b+k));
        cout<<(-b+k)/f;
        if(2*a/f!=1) cout<<"/"<<2*a/f;
        cout<<endl;
        return;
    }
    if(delta==0){
        int f=abs(gcd(2*a,-b));
        cout<<-b/f;
        if(2*a/f!=1) cout<<"/"<<2*a/f;
        cout<<endl;
        return;
    }
    int f=abs(gcd(-b,2*a));
    if(b==0){
        f=abs(gcd(k,2*a));
        if(k/f!=1) cout<<k/f<<"*";
        cout<<"sqrt("<<delta/(k*k)<<")";
        if(2*a/f!=1) cout<<"/"<<2*a/f;
        cout<<endl;
        return;
    }
    cout<<-b/f;
    if(2*a/f!=1) cout<<"/"<<2*a/f;
    cout<<"+";
    f=abs(gcd(k,2*a));
    if(k/f!=1) cout<<k/f<<"*";
    cout<<"sqrt("<<delta/(k*k)<<")";
    if(2*a/f!=1) cout<<"/"<<2*a/f;
    cout<<endl;
    return;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    freopen("uqe.in","r",stdin);
    freopen("uqe.out","w",stdout);
    cin>>t>>m;
    while(t--){
        solve();
    }
    return 0;
}
~~~
结果如下：  
![](https://images.cnblogs.com/cnblogs_com/blogs/811181/galleries/2377257/o_240209141202_QQ%E6%88%AA%E5%9B%BE20240209221148.jpg)
___  
## 第四题 旅游巴士
原题[洛谷P9751](https://www.luogu.com.cn/problem/P9751)
### 题目描述
小 Z 打算在国庆假期期间搭乘旅游巴士去一处他向往已久的景点旅游。  
旅游景点的地图共有 $n$ 处地点，在这些地点之间连有 $m$ 条道路。其中 $1$ 号地点为景区入口，$n$ 号地点为景区出口。我们把一天当中景区开门营业的时间记为 $0$ 时刻，则从 $0$ 时刻起，每间隔 $k$ 单位时间便有一辆旅游巴士到达景区入口，同时有一辆旅游巴士从景区出口驶离景区。  
所有道路均只能**单向通行**。对于每条道路，游客步行通过的用时均为恰好 $1$ 单位时间。  
小 Z 希望乘坐旅游巴士到达景区入口，并沿着自己选择的任意路径走到景区出口，再乘坐旅游巴士离开，这意味着他到达和离开景区的时间都必须是 **$k$ 的非负整数倍**。由于节假日客流众多，**小 Z 在旅游巴士离开景区前只想一直沿着景区道路移动，而不想在任何地点（包括景区入口和出口）或者道路上停留**。  
出发前，小 Z 忽然得知：景区采取了限制客流的方法，对于每条道路均设置了一个
“开放时间”$a _ i$，游客只有**不早于 $a _ i$ 时刻**才能通过这条道路。  
请帮助小 Z 设计一个旅游方案，使得他乘坐旅游巴士离开景区的时间尽量地早。  
### 输入格式
输入的第一行包含 3 个正整数 $n, m, k$，表示旅游景点的地点数、道路数，以及旅游巴士的发车间隔。  
输入的接下来 $m$ 行，每行包含 3 个非负整数 $u _ i, v _ i, a_ i$，表示第 $i$ 条道路从地点 $u _ i$ 出发，到达地点 $v _ i$，道路的“开放时间”为 $a _ i$。  
### 输出格式
输出一行，仅包含一个整数，表示小 Z 最早乘坐旅游巴士离开景区的时刻。如果不存在符合要求的旅游方案，输出 `-1`。  
### 样例 #1
#### 样例输入 #1
```
5 5 3
1 2 0
2 5 1
1 3 0
3 4 3
4 5 1
```
#### 样例输出 #1
```
6
```
### 提示
**【样例 #1 解释】**  
小 Z 可以在 $3$ 时刻到达景区入口，沿 $1 \to 3 \to 4 \to 5$ 的顺序走到景区出口，并在 $6$ 时刻离开。  
**【样例 #2】**  
见附件中的 `bus/bus2.in` 与 `bus/bus2.ans`。  
**【数据范围】**  
对于所有测试数据有：$2 \leq n \leq 10 ^ 4$，$1 \leq m \leq 2 \times 10 ^ 4$，$1 \leq k \leq 100$，$1 \leq u _ i, v _ i \leq n$，$0 \leq a _ i \leq 10 ^ 6$。  
| 测试点编号 | $n \leq$ | $m \leq$ | $k \leq$ | 特殊性质 |
|:-:|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ |$15$ | $100$ | $a _ i = 0$ |
| $3 \sim 5$ | $10$ | $15$ | $100$ | 无 |
| $6 \sim 7$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $1$ | $a _ i = 0$ |
| $8 \sim 10$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $1$ | 无 |
| $11 \sim 13$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $100$ | $a _ i = 0$ |
| $14 \sim 15$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $100$ | $u _ i \leq v _ i$ |
| $16 \sim 20$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $100$ | 无 |
### 分析  
题目有这样两句话  
>他到达和离开景区的时间都必须是 **$k$ 的非负整数倍**  
>景区采取了限制客流的方法，对于每条道路均设置了一个“开放时间”$a _ i$，游客只有**不早于 $a _ i$ 时刻**才能通过这条道路

假设当 $t$ 时刻时，位于 $i$ 地点，与 $i$ 点相连的有 $j_1,j_2,...,j_m$ 点，他们相应的限制时间为 $a_1,a_2,...,a_m$，设现在要到达 $j_x$ 点， $j_x$ 点的时间限制为 $a_x$   
因为游客只有**不早于 $a _ i$ 时刻**才能通过这条道路  
所以
1. 当 $a_x>t$ 时，小Z不能通过这条路  
2. 当 $a_x<=t$ 时，小Z能通过这条路，通过这条路后时间变为 $t+1$  

对于当 $t$ 时刻不能通行的道路，我们可以这样处理：~~规则？规则就是用来打破的！~~ 等待，直到能通过这条路  
因为题目说了不能原地等待，所以我们只能在起点等待   
$t$ 时刻与 $a_x$ 时刻相差了 $a_x-t$ 的时间，则小Z至少要在起点等待 $a_x-t$ 的时间，因为到达和离开景区的时间都必须是 $k$ 的非负整数倍，所以应在起点等待的时间为 $\lceil \frac{a_x-t}{k} \rceil\times k$,到达 $i$ 点的时间为$\lceil \frac{a_x-t}{k} \rceil\times k+t$  

该题有一个特殊的地方，它所求的答案并非最小值，而是能被 $k$ 整除的最小值。  
并且 $k$ 并不大  
于是我们想到定义 $dis_{i,j}$ 来表示：  
到达$i$点的时间 $t \bmod k$ 恰好 $j$ 的值的最短时间  
答案存在$dis_{n,0}$  
（我相信除了我本人以外的大部分人是看不懂的，~~因为我语文不好~~）  
for example:  
**如 图 所 示**
![](https://images.cnblogs.com/cnblogs_com/blogs/811181/galleries/2377257/o_240209132351_QQ%E6%88%AA%E5%9B%BE20240209212338.jpg)
**仅为模拟**  
假设 $k=5$  
到D点一共有 $3$ 种走法  
A->F->D  
A->B->D  
A->B->C->D  
1. A->F的路段限制时间为$0$，$dis_{A,0}=0,dis_{F,1}=1$，  
F->D的路段限制时间为$0$,$dis_{D,2}=2$
2. A->B的路段限制时间为$0$,$dis_{B,1}=1$,  
B->D的路段限制时间为$3$, 由上文公式 $\lceil \frac{a_x-t}{k} \rceil\times k+t$ 可得：若要经过点D,则应在入口等待5个单位时间再出发，到达D点的时间为7，则 $dis_{D,7\bmod 5}=7$,即 $dis_{D,2}=7$ ($dis_{B,1}仍然=1$)  
由第一条得$dis_{D,2}=2$,因为$2<7$，所以$dis_{D,2}应取2$  
3. A->B的路段限制时间为$0$，$dis_{B,1}=1$,B->C的路段限制时间为1，$dis_{C,2}=2$,C->D路段的限制时间为2，$dis{D,3}=3$  
所以$dis_{D,0}=???,dis_{D,1}=???,dis_{D,2}=2,dis_{D,3}=3,(“???”表示没有)$  
解释完了那答案存哪里就显而易见了：$dis_{n,0}$  

至于最短路算法：
因为全是正边，所以不会被卡掉的$dijkstra$算法比较好？

那么代码如下：
~~~
//写成这样大概逻辑更清晰？？？
#include <iostream>
#include <cstring>
#include <vector>
#include <queue>
#define int long long//我也很好奇为什么会超int型
using namespace std;
const int N=1e4+5,M=105;
int n,m,k,dis[N][M],vis[N][M];//N表示n个点，m表示时间modk后的结果
vector<pair<int,int>>edge[N];//邻接表
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;//小根堆优化dijkstra算法
//q.top().first表示时间，q.top().second表示是什么点
void add(int a,int b,int c){//建边
    edge[a].push_back({b,c});
}
void bian(){//建图
    for(int i=1,u,v,a;i<=m;i++){
        cin>>u>>v>>a;
        add(u,v,a);
    }
}
void dijkstra(int x){//很好用的算法，但是名字不太好记
    dis[x][0]=0;//基本就是模版
    q.push({0,x});
    while(q.size()){
        int u=q.top().second,p=q.top().first;
        q.pop();
        if(vis[u][p%k]) continue;
        vis[u][p%k]=1;
        for(auto d:edge[u]){
            int v=d.first,w=d.second,time1;
            if(p>=w) time1=p;
            else time1=((w-p-1)/k+1)*k+p;
            if(dis[v][(time1+1)%k]>time1+1){
                dis[v][(time1+1)%k]=time1+1;
                q.push({time1+1,v});
            }
        }
    }
}
void solve(){//真正的主函数
    memset(dis,0x3f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    cin>>n>>m>>k;
    bian();
    dijkstra(1);
    if(vis[n][0]==0) cout<<-1;
    else cout<<dis[n][0];
}
signed main(){//虚假的主函数
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);//不写#include <cstdio>导致的
    freopen("bus.in","r",stdin);
    freopen("bus.out","w",stdout);
    solve();
    return 0;
}
~~~
运行结果如下：
![](https://images.cnblogs.com/cnblogs_com/blogs/811181/galleries/2377257/o_240209072219_QQ%E6%88%AA%E5%9B%BE20240209152158.jpg)
## 结尾
终于写完了，新年礼物哈哈哈